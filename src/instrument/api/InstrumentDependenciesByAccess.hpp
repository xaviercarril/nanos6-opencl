/*
	This file is part of Nanos6 and is licensed under the terms contained in the COPYING file.
	
	Copyright (C) 2015-2017 Barcelona Supercomputing Center (BSC)
*/

#ifndef INSTRUMENT_DEPENDENCIES_BY_ACCESS_HPP
#define INSTRUMENT_DEPENDENCIES_BY_ACCESS_HPP


#include <InstrumentInstrumentationContext.hpp>
#include <InstrumentThreadInstrumentationContext.hpp>

#include "dependencies/DataAccessType.hpp"

#include <cstddef>


namespace Instrument {
	//! \file
	//! \name Dependency instrumentation by accesses
	//! @{
	//! This group of functions is useful for instrumenting task dependencies. This is an exhaustive interface in
	//! the sense that it provides almost all the information necessary to calculate the whole graph. The only
	//! missing information is that of task nesting and taskwaits. However, this information is also available
	//! through other groups of instrumentation functions.
	//! 
	//! This interface in essence passes on the information generated by the user-side code to calculate the
	//! dependencies.
	
	//! \brief Identifies an access that could lead to a dependency
	//!
	//! \param[in] taskId the task_id_t returned by a call to Instrument::enterAddTask
	//! \param[in] accessType the type of access
	//! \param[in] weak true if the access is weak
	//! \param[in] start the starting address of the access
	//! \param[in] length the length of the access is bytes
	void registerTaskAccess(task_id_t taskId, DataAccessType accessType, bool weak, void *start, size_t length, InstrumentationContext const &context = ThreadInstrumentationContext::getCurrent());
	
	//! @}
}


#endif // INSTRUMENT_DEPENDENCIES_BY_ACCESS_HPP
